Application Model
=================

The application model is used to describe the application hierarchy, fetch
application specific information and access application data.

The base application node inherits from ``zodict.node.LifecycleNode``. This
has some advantages:

    - ``repoze.bfg`` expects dict like objects for traversal, so we already
      fulfill this contract by using Nodes.
    
    - It is ordered.
    
    - Nodes know about it's location so we can easily generate URL's out of
      ``Node.path``.
    
    - The model is held in memory. ``LifecycleNode`` triggers object events
      when it is modified, so we can subscribe to this events for data or tree
      manipulation or trigger those events ourself, i.e. on cache timeouts.
    
    - Nodes have an index holding references to all contained Nodes in the tree
      by uid. This makes it easy to access information from other Nodes in the
      tree.

``bda.bfg.app.interfaces.IApplicationNode`` extend this interface by:

    - An ``__acl__`` property defining security. See documentation of
      ``repoze.bfg.security`` for details.
    
    - A ``properties`` property, holding app specific information, i.e.
      'in_navtree', which is used by ``navtree`` tile to determine wether this
      node should be displayed in navigation tree or not. Use this property
      if you need 'by-node' configuration in your application.
    
    - A ``metadata`` property, containing an IMetadata implementation.
      ``bda.bfg.app.model.BaseNode`` returns by default, a
      ``bda.bfg.app.model.BaseMetadata`` instance. This
      base implementation is an adapter like object wrapping any dict like
      object, is case of ``BaseNode`` the data for metadata is
      ``BaseNode.attrs``.
    
    - A ``title`` property as convenience. This might get removed in future.

BaseNode
--------
::

    >>> from bda.bfg.app.model import BaseNode
    >>> root = BaseNode()

Default permissions.
::

    >>> root.__acl__
    [('Allow', 'group:authenticated', 'view'), 
    ('Allow', 'system.Everyone', 'login'), 
    ('Deny', 'system.Everyone', 
    <repoze.bfg.security.AllPermissionsList object at ...>)]

Base implementation does not define any properties.
::

    >>> root.properties
    {}

Metadata of base implementation maps to base implementation's ``attr`` property.
::

    >>> root.metadata._data() is root.attrs
    True
    
``title`` property returns either ``properties['title']`` or ``Node.__name__``.
::

    >>> root.__name__ = 'foo'
    >>> root.title
    'foo'
    
    >>> root.attrs.title = 'Foo Title'
    >>> root.title
    'Foo Title'

Now ``metadata.title`` is available as well since ``BaseNode.metadata`` just
wraps ``BaseNode.attrs``.
::

    >>> root.metadata.title
    'Foo Title'

``IMetadata`` implementations do not raise AttributeErrors if requested metadata
not exists.
::

    >>> root.metadata.inexistent

FactoryNode
-----------

You can use the factory node to build static structures. It created the child
Node for ``key`` on ``__getitem__`` if not existent yet.
::

    >>> from bda.bfg.app.model import FactoryNode
    >>> class Root(FactoryNode):
    ...     factories = {
    ...         'foo': BaseNode,
    ...         'bar': BaseNode,
    ...     }
    
    >>> root = Root()
    >>> root['foo']
    <BaseNode object 'foo' at ...>
    
    >>> root['bar']
    <BaseNode object 'bar' at ...>
    
    >>> root['baz']
    Traceback (most recent call last):
      ...
    KeyError

NodeAdapter
-----------

A NodeAdapter is intended to be used if you want to publish some other kind of
node implementing data structures.

Since other Node tree implementations depend on its own internal hierarchy and
do not provide the extensions described in
``bda.bfg.app.interfaces.IApplicationNode``, we have to wrap it inside a
Node adapter in order to use it inside the application.

The node adapter calls for common read operations the equivalent functions on
it's adapted Node.
::

    >>> from zodict.node import AttributedNode
    >>> from bda.bfg.app.model import NodeAdapter
    
    >>> toadapt = AttributedNode()
    >>> toadapt['foo'] = AttributedNode()
    >>> toadapt['bar'] = AttributedNode()
    >>> toadapt.attrs.title = 'Some title'
    >>> toadapt.attrs.description = 'Some description'

Adapt created node structure.
::

    >>> adapter = NodeAdapter(toadapt, 'name', None)

Check ``INodeAdapter`` interface.

``__getitem__``
::

    >>> adapter['foo']
    <AttributedNode object 'foo' at ...>

``__contains__``
::

    >>> 'bar' in adapter
    True

``__len__``
::

    >>> len(adapter)
    2

``__iter__``
::

    >>> [key for key in adapter]
    ['foo', 'bar']

``keys``
::

    >>> adapter.keys()
    ['foo', 'bar']

``values``
::

    >>> adapter.values()
    [<AttributedNode object 'foo' at ...>, 
    <AttributedNode object 'bar' at ...>]

``items``
::

    >>> adapter.items()
    [('foo', <AttributedNode object 'foo' at ...>), 
    ('bar', <AttributedNode object 'bar' at ...>)]

``get``
::

    >>> adapter.get('bar')
    <AttributedNode object 'bar' at ...>

``attrs``
::

    >>> adapter.attrs.title
    'Some title'
    
The node adapter is responsible to return other node adapters or application
nodes on ``__getitem__`` if application hierarchy continues.

You can do key aliasing as well at this place.
::

    >>> class MyNodeAdapter(NodeAdapter):
    ...     def __getitem__(self, key):
    ...         return NodeAdapter(self.node['bar'], key, self)

This dummy class does a static mapping on __getitem__.
::

    >>> node = MyNodeAdapter(toadapt, 'adapter', None)
    >>> child = node['aliased']
    >>> child
    <NodeAdapter object 'aliased' at ...>
    
    >>> child.node
    <AttributedNode object 'bar' at ...>

The application node path differs from the adapted node path. This is essential
to keep the application path sane while not violating the adapted node's
structure.
::

    >>> child.path
    ['adapter', 'aliased']
    
    >>> child.node.path
    [None, 'bar']

Metadata
--------

The ``IMetadata`` implementation returned by ``IApplicationNode.metadata`` is
used by the application for displaying metadata information.

The default implementation accepts a dict like object on ``__init__``.
::

    >>> from bda.bfg.app.model import BaseMetadata
    >>> data = {
    ...     'title': 'some title',
    ...     'description': 'some description',
    ...     'creator': 'john doe',
    ... }

Check ``INodeAdapter`` interface.
::

    >>> metadata = BaseMetadata(data)

``__getattr__``. No AttributeError is raised if attribute is inexistent.
::

    >>> metadata.title
    'some title'
    
    >>> metadata.description
    'some description'
    
    >>> metadata.creator
    'john doe'
    
    >>> metadata.inexistent

``__getitem__``
::

    >>> metadata['title']
    'some title'

``__contains__``
::

    >>> 'description' in metadata
    True

``get``
::

    >>> metadata.get('creator')
    'john doe'